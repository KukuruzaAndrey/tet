const border = '\u001B[7m \u001B[m'

const boardW = 10
const boardH = 20

const getRandomIntInclusive = (min, max) => {
  return Math.floor(Math.random() * (max - min + 1)) + min
}
const moves = {
  auto: 0,
  left: 1,
  right: 2,
  down: 3,
  rotate: 4,
}

const figures = [
  [
    { squares: [[0, 0], [0, 1], [0, 2], [0, 3]], h: 4, w: 1 },
    { squares: [[0, 0], [1, 0], [2, 0], [3, 0]], h: 1, w: 4 }
  ], // I
  [
    { squares: [[0, 0], [0, 1], [0, 2], [1, 2]], h: 3, w: 2 },
    { squares: [[0, 1], [1, 1], [2, 1], [2, 0]], h: 2, w: 3 },
    { squares: [[0, 0], [1, 0], [1, 1], [2, 1]], h: 3, w: 2 },
    { squares: [[0, 0], [1, 0], [2, 0], [0, 1]], h: 2, w: 3 }
  ], // L
  [
    { squares: [[1, 0], [2, 0], [0, 1], [1, 1]], h: 2, w: 3 },
    { squares: [[0, 0], [0, 1], [1, 1], [1, 2]], h: 3, w: 2 }
  ], // S
  [
    { squares: [[0, 0], [1, 0], [1, 1], [2, 1]], h: 2, w: 3 },
    { squares: [[0, 1], [1, 0], [1, 1], [0, 2]], h: 3, w: 2 }
  ], // Z
  [
    { squares: [[0, 0], [0, 1], [1, 1], [1, 0]], h: 2, w: 2 }
  ], // O
  [
    { squares: [[0, 0], [1, 0], [2, 0], [1, 1]], h: 2, w: 3 },
    { squares: [[1, 0], [0, 1], [1, 1], [1, 2]], h: 3, w: 2 },
    { squares: [[1, 0], [0, 1], [1, 1], [2, 1]], h: 2, w: 3 },
    { squares: [[0, 0], [0, 1], [0, 2], [1, 1]], h: 3, w: 2 }
  ]  // T
]

// const getNewFigure = () => {
//   const fig = figures[getRandomIntInclusive(0, figures.length - 1)]
//   return fig[getRandomIntInclusive(0, fig.length - 1)]
// }

const getNewFigure = () => figures[getRandomIntInclusive(0, figures.length - 1)]

const state = {
  board: [], active: [], rotation: 0, offset: [], figCoords: [], move: 0
}

const init = (state) => {
  for (let y = 0; y < boardH; y++) {
    const row = []
    for (let x = 0; x < boardW; x++) {
      row.push(0)
    }
    state.board.push(row)
  }

  newPiece(state)
  state.move = 0
}

const newPiece = (state) => {
  state.active = getNewFigure()
  state.rotation = getRandomIntInclusive(0, state.active.length - 1)
  state.offset = [4, -1]
  state.figCoords = getCurrentFigCoords()
}
const canMoveRight = () => {
  return (state.offset[0] + getCurrPiece().w < boardW) && state.figCoords.every(([x, y]) => board(x + 1, y) !== 1)
}

const canMoveLeft = () => {
  return (state.offset[0] > 0) && state.figCoords.every(([x, y]) => board(x - 1, y) !== 1)
}

const canRotate = () => {
  return true
}

const board = (x, y) => state.board[y][x]
const getCurrPiece = () => state.active[state.rotation]

const update = (state) => {
  switch (state.move) {
    case moves.auto:
    case moves.down:
      state.offset[1] += 1
      break
    case moves.right:
      if (canMoveRight())
        state.offset[0] += 1
      break
    case moves.left:
      if (canMoveLeft())
        state.offset[0] -= 1
      break
    case moves.rotate:
      if (canRotate()) {
        if (state.rotation === state.active.length - 1) {
          state.rotation = 0
        } else {
          state.rotation += 1
        }
      }
      break
  }

  state.figCoords = getCurrentFigCoords()

  if (state.figCoords.some(([x, y]) => (y + 1 === boardH) || (board(x, y + 1) === 1))) {
    state.figCoords.forEach(([x, y]) => {
      state.board[y][x] = 1
    })

    newPiece(state)
  }

  for (let y = 0; y < boardH; y++) {
    if (state.board[y].every(c => c === 1)) {
      for (let x = 0; x < boardW; x++) {
        state.board[y][x] = 0
      }
    }
  }

}
const getCurrentFigCoords = () => getCurrPiece().squares.map(([x, y]) => [x + state.offset[0], y + state.offset[1]])

const render = (state) => {
  let res = ''
  for (let x = 0; x < boardW + 2; x++) {
    res += '.'
  }
  res += '\n'

  for (let y = 0; y < boardH; y++) {
    res += '.'
    for (let x = 0; x < boardW; x++) {
      if (board(x, y) === 1) {
        res += border
      } else if (state.figCoords.some(([xc, yc]) => xc === x && yc === y)) {
        res += border
      } else {
        res += ' '
      }
    }
    res += '.'
    res += '\n'
  }
  for (let x = 0; x < boardW + 2; x++) {
    res += '.'
  }
  res += '\n'

  return res
}

init(state)
const step = state => {
  update(state)
  console.log(render(state))
}
const int = setInterval(() => {
  if (state !== 'game_over') {
    // console.log(move.turn)
    state.move = moves.auto
    step(state)
    // move = step(move)
    // console.log(JSON.stringify(move))
  } else {
    clearInterval(int)
  }
}, 300)
const stdin = process.stdin
stdin.setRawMode(true)
// console.log(stdin.isTTY)
stdin.setEncoding('utf8')

stdin.on('data', chunk => {
  // var option = chunk.substr(0, chunk.length - 1)
  switch (chunk) {
    case '\u001b[A':
      // console.log('Up')
      // state.offset

      break
    case '\u001b[B':
      state.move = moves.down
      step(state)
      // console.log('Down')
      break
    case '\u001b[C':
      state.move = moves.right
      step(state)
      break
    case '\u001b[D':
      state.move = moves.left
      step(state)
      break
    case ' ':
      state.move = moves.rotate
      step(state)
      break
    case '\u0003':
      console.log('Exit')
      process.exit()
      break
    case 'something_else':
      // Perform what something_else does
      break
  }
})
